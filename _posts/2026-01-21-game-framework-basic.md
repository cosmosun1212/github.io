---

layout: post

title:  "\[C언어로 게임만들기] 게임의 기본 프레임 만들기"

date:   2026-01-21 11:30:00 +0900

categories: \[C언어로 게임만들기]

tags: \[C언어, 게임개발, 유니티, GameLoop]

---



\## 게임 엔진의 심장, 메인 루프 (Main Loop)



게임을 만든다는 것은 무엇일까요? 단순히 화면에 그림을 띄우는 것이 아닙니다. 게임은 끊임없이 \*\*입력을 받고, 계산하고, 화면을 그리는 과정\*\*의 반복입니다. 이것을 우리는 \*\*게임 루프(Game Loop)\*\*라고 부릅니다.



오늘은 C언어로 게임을 만들지만, 실제로는 \*\*유니티(Unity) 엔진의 내부 구조\*\*와 비슷한 형태의 프레임으로 만들어 보겠습니다. 

이 구조를 이해하면 나중에 유니티를 배울 때 "아! 이게 그때 그 기능이구나!" 하고 무릎을 탁 치게 될 겁니다.



\### 1. 전체 코드 구조



우리가 앞으로 채워나갈 게임의 뼈대입니다. `main` 함수 안에 있는 `while(1)`이 바로 게임의 심장입니다.



```cpp

int main(void)

{

&nbsp;   // \[1] 초기화 단계

&nbsp;   Awake(); // 객체 생성 및 변수 초기화 (유니티: GetComponent 등)

&nbsp;   Start(); // 활성화 시점의 초기화 (유니티: 실제 로직 준비)



&nbsp;   InitTime(); // 시간 타이머 초기화



&nbsp;   while (1)

&nbsp;   {

&nbsp;       // \[2] 시간 계산 (Time.deltaTime)

&nbsp;       // 현재 프레임에 걸린 시간을 계산하여 변수에 저장

&nbsp;       UpdateTime(); 



&nbsp;       // \[3] 입력 처리 (Input System)

&nbsp;       // 키보드/마우스 상태를 미리 캡처하여 버퍼에 저장

&nbsp;       ProcessInput(); 



&nbsp;       // \[4] 물리 연산 (FixedUpdate)

&nbsp;       // 지정된 시간 간격(예: 0.02초)마다 실행. 

&nbsp;       // 렉이 걸려도 물리 연산 횟수는 보장됨 (while문 사용)

&nbsp;       while (NeedFixedUpdate()) 

&nbsp;       {

&nbsp;           FixedUpdate();

&nbsp;       }



&nbsp;       // \[5] 게임 로직 (Update)

&nbsp;       // 매 프레임마다 실행 (이동, 공격, 타이머 등)

&nbsp;       Update();



&nbsp;       // \[6] 후처리 로직 (LateUpdate)

&nbsp;       // Update가 끝난 후 실행 (카메라 이동, 위치 보정)

&nbsp;       LateUpdate();



&nbsp;       // \[7] 렌더링 파이프라인

&nbsp;       PreRender();  // 더블 버퍼링 클리어 등

&nbsp;       Render();     // 실제 그리기

&nbsp;       PostRender(); // 버퍼 교체 (Flip) 등

&nbsp;   }



&nbsp;   Release(); // 메모리 해제 (OnDestroy)

&nbsp;   

&nbsp;   return 0;

}



\### 2. 각 함수는 무슨 일을 할까?

위 코드가 왜 이런 순서로 되어 있는지, 각 함수가 유니티에서는 어떤 역할을 하는지 하나씩 상세하게 뜯어보겠습니다.



\[1] 탄생과 준비: Awake()와 Start()

게임이 시작되기 전 딱 한 번 실행되는 초기화 단계입니다. 유니티에서도 가장 많이 헷갈리는 두 녀석이죠.



Awake() ("나 태어났어!")



역할: 메모리를 할당하고 변수를 0으로 초기화하는 등 가장 기초적인 작업을 합니다.



Unity: void Awake() - 주로 GetComponent로 자신의 컴포넌트를 가져올 때 사용합니다.



Start() ("나 갈 준비 됐어!")



역할: 모든 객체의 Awake가 끝난 후, 본격적인 로직 시작 직전에 실행됩니다. 다른 객체와 통신하거나 데이터를 설정합니다.



Unity: void Start() - 다른 스크립트의 변수를 참조하거나 초기값 설정을 마무리할 때 사용합니다.



\[2] 시간의 지배자: UpdateTime()

컴퓨터마다 성능이 다릅니다. 좋은 컴퓨터는 1초에 루프를 200번 돌고, 느린 컴퓨터는 30번 돕니다.



문제: 컴퓨터가 빠르다고 캐릭터가 10배 빨리 움직이면 안 되겠죠?



해결: \*\*'지난 프레임에서 이번 프레임까지 걸린 시간(Delta Time)'\*\*을 계산합니다. 이 값을 이동 거리에 곱해주면, 어떤 성능의 컴퓨터에서도 캐릭터는 똑같은 속도로 움직입니다.



Unity: Time.deltaTime



\[3] 귀를 기울이다: ProcessInput()

사용자의 명령을 듣는 단계입니다.



역할: 키보드, 마우스가 눌렸는지 운영체제(Windows)에게 물어보고 그 상태를 저장합니다.



이유: 게임 로직(Update)이 시작되기 전에 미리 입력을 받아놔야, 로직 중간에 입력이 바뀌거나 씹히는 현상을 방지할 수 있습니다.



Unity: Input.GetKeyDown, Input.GetAxis



\[4] 물리 법칙의 시간: FixedUpdate()

이곳은 시간이 일정하게 흐르는 공간입니다.



왜 while문일까?: 화면 그리기(Update)는 컴퓨터가 느려지면 같이 느려질 수 있습니다. 하지만 물리 법칙(충돌, 중력)은 렉이 걸린다고 벽을 뚫고 지나가면 안 됩니다. 그래서 밀린 물리 계산이 있다면 반복문을 돌려서라도 강제로 횟수를 채워서 처리합니다.



Unity: void FixedUpdate() - 물리 엔진(Rigidbody)은 반드시 여기서 다뤄야 합니다.



\[5] 게임의 본방: Update()

여러분이 작성할 게임 코드의 90%가 들어가는 곳입니다.



역할: 매 프레임마다 반복해서 실행해야 하는 일들을 처리합니다. (캐릭터 이동, 총알 발사, 스킬 쿨타임 체크 등)



Unity: void Update()



\[6] 뒤수습 전문가: LateUpdate()

모든 Update가 끝난 뒤에 "혹시 빠뜨린 거 없나?" 하고 마지막으로 실행됩니다.



핵심 역할: 카메라(Camera)



주인공이 Update에서 이동을 마친 뒤에, 카메라가 LateUpdate에서 주인공 위치로 따라가야 화면이 덜덜 떨리지 않고 부드럽게 따라갑니다. 주인공보다 카메라가 먼저 움직이면 안 되니까요.



Unity: void LateUpdate()



\[7] 화가의 시간: Render()

모든 계산이 끝났으니 이제 모니터에 결과를 보여줍니다.



PreRender: 칠판(버퍼)을 깨끗이 지웁니다.



Render: 보이지 않는 뒷장(Back Buffer)에 그림을 그립니다.



PostRender: 다 그린 그림을 모니터 앞으로 휙! 하고 꺼내 놓습니다. (더블 버퍼링 기법)

